
## Python optimizer for LTspice, Bob Adams, Fellow Emeritus, Analog Devices 2023 (C)
## optimizer will adjust selected schematic components (designated in the setup file function 'simControl')
## in an attempt to match the target response, set in the setup file function 'setTarget'

## Note, the schematic name is read from the simControl function
## which is imported from the setup python file (see line below)
## The setup file must be generated by the user for a particular LTspice schematic and sim
## See any of the example files in this distribution for an example
## Un-comment 1 of the following to run the example, or import your own setup file





# from example1_setup import simControl, setTarget
from example2_setup import simControl, setTarget
#  from example2_diff_setup import simControl, setTarget
#  from hilbert_example_setup import simControl, setTarget
# from testTran_setup import simControl, setTarget

# notes:

# the simControl function sets the following;
# ** paths to the LTspice executable
# ** working LTspice directory
# ** schematic instance names and/or parameter names to be optimized
# ** min and max values of those instances or parameters
# ** tolerance of those instances
# ** match mode (amplitude only, phase only, or both)
# ** The max number of iterations for both the particle swarm algorithm and the least-squares algorithm

# the setTarget function sets the target amplitude and/or phase response
# It is calculated at the same frequencies as used in
# the .ac spice control line in the schematic
# It also sets the error weights; if you want more precise matching in some frequency
# regions, you can increase the error weights in that frequency region. If the specification style is
# passband/don't-care band/stopband, then the error weights can be set to be constant within those 3 frequency regions (see example2)


import numpy as np
from numpy import random
import matplotlib.pyplot as plt
import os
import subprocess
import time
import sys
import hashlib

from PyLTSpice import RawRead # user must install into env from https://pypi.org/project/PyLTSpice/
from scipy.optimize import least_squares

import pyswarms as ps
from pyswarms.utils.functions import single_obj as fx
from myPlots import myPlot_1x,myPlot_2x,myPlot_3x,myPlot_2x_errweights,myPlot_1x_errweights


print('******\n******\nCopyright (C) Robert Adams 2023\n******\n******')

# LTspice Optimizer
# Copyright (C) Robert Adams 2023

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.



plt.interactive(True)

# Initialize global variables
spiceSimCount_lsq = 0  # spice sim count for the least-squares
iterationCount_ps = 0  # iteration count for the particle swarm

passCellDict = {}  # empty dict

# ******************************* functions ***************************


def pswarm(optParams): # this is the evaluation function called particle swarm
    global passCellDict
    global iterationCount_ps


    RunLTstring = passCellDict['RunLTstringD']
    LTspice_outputfile = passCellDict['LTspice_outputfileD']
    LTspice_output_node = passCellDict['LTspice_output_nodeD']
    matchMode = passCellDict['matchModeD']
    target = passCellDict['targetD']
    errWeights = passCellDict['errWeightsD']
    nomParams = passCellDict['nomParamsD']
    numOptd = passCellDict['numOptdD']
    numParticles = len(optParams)
    rmserrRet = np.zeros(numParticles)
    # bestRMS = 1e12
    for kk in range(numParticles):  # this is called with a vector of all particle positions at once
        componentVal = np.zeros(numOptd)
        for k in range(numOptd):
            componentVal[k] = optParams[kk,k] * nomParams[k]  # de-normalize
            #write_netlist(componentVal,optParams)
        update_netlist(passCellDict,componentVal)

        time.sleep(0.02)
        runSim(LTspice_outputfile, RunLTstring)  # get result by reading spice output file
        time.sleep(0.02)
        LTR = RawRead(LTspice_outputfile)
        outNode = LTR.get_trace(LTspice_output_node)
        if matchMode < 4: # freq sweep sim
            fresp = np.abs(outNode)
            freqx = LTR.get_trace('frequency')
            freqx = np.abs(freqx)
            if matchMode == 2 or matchMode == 3:
                phase = np.unwrap(np.angle(outNode))

            if matchMode == 1:  # ampl only
                optCurrent = fresp
            if matchMode == 2:  # phase only
                optCurrent = phase
            if matchMode == 3:  # ampl and phase
                optCurrent = np.concatenate((fresp, phase))

            if len(target) != len(optCurrent):
                print('ERROR, something went wrong with the LTspice sim...')
                sys.exit()
        if matchMode == 4: # time-domain transient sim
            numTimePoints = passCellDict['numTimePointsD']
            timex = LTR.get_trace('time')
            timex = np.abs(timex)  ## sometimes the function returns a neg value, but otherwise correct ??
            timexLinspace = np.linspace(np.min(timex), np.max(timex), numTimePoints)
            optCurrent = np.interp(timexLinspace, timex, outNode)

        err = target - optCurrent  # error between target and current response

        err = err * errWeights  # apply frequency-dependent optimization
        rmsErr = np.sqrt(np.mean(err ** 2))
        rmserrRet[kk] = rmsErr
        # if rmsErr < bestRMS:
        #     bestRMS = rmsErr

    return rmserrRet

def optLTspice(optParams, *args, **kwargs): # this is the evaluation function called by sciPy least-squares
    global spiceSimCount_lsq  # the iterCount_lsq is derived from the spice sim count


    # netlist_fname = kwargs['netlist_fnameD']
    RunLTstring = kwargs['RunLTstringD']
    LTspice_outputfile = kwargs['LTspice_outputfileD']
    LTspice_output_node = kwargs['LTspice_output_nodeD']
    matchMode = kwargs['matchModeD']
    target = kwargs['targetD']
    errWeights = kwargs['errWeightsD']
    # numlines_netlist = kwargs['numlines_netlistD']
    # netlist = kwargs['netlistD']
    nomParams = kwargs['nomParamsD']
    # OptLine = kwargs['OptLineD']
    numOptd = kwargs['numOptdD']
    maxIter_lsq = kwargs['maxIter_lsqD']
    componentVal = np.zeros(numOptd)
    for k in range(numOptd):
        componentVal[k] = optParams[k]*nomParams[k]  # de-normalize
    update_netlist(passCellDict,componentVal)
    time.sleep(0.1)
    runSim(LTspice_outputfile,RunLTstring)  # get result by reading spice output file

    LTR = RawRead(LTspice_outputfile)
    outNode = LTR.get_trace(LTspice_output_node)

    if matchMode < 4:  # freq sweep sim
        fresp = np.abs(outNode)
        freqx = LTR.get_trace('frequency')
        freqx = np.abs(freqx)
        if matchMode == 2 or matchMode == 3:
            phase = np.unwrap(np.angle(outNode))

        if matchMode == 1:  # ampl only
            optCurrent = fresp
        if matchMode == 2:  # phase only
            optCurrent = phase
        if matchMode == 3:  # ampl and phase
            optCurrent = np.concatenate((fresp, phase))

        if len(target) != len(optCurrent):
            print('ERROR, something went wrong with the LTspice sim...')
            sys.exit()
    if matchMode == 4:  # time-domain transient sim
        numTimePoints = passCellDict['numTimePointsD']
        timex = LTR.get_trace('time')
        timex = np.abs(timex)  ## sometimes the function returns a neg value, but otherwise correct ??
        timexLinspace = np.linspace(np.min(timex), np.max(timex), numTimePoints)
        optCurrent = np.interp(timexLinspace, timex, outNode)


    err = target - optCurrent  # error between target and current response

    err = err * errWeights  # apply frequency-dependent optimization
    iterationCount_lsq = int(spiceSimCount_lsq/(numOptd+1))
    if iterationCount_lsq > maxIter_lsq:  # set error to large # to stop the algorithm
        err.fill(1e3)
        printme = 'Stopping ...'
        print('\r', printme, end="")
    else:
        rmsErr = np.sqrt(np.mean(err ** 2))
       # printme = "least-sq spice sim count, rms Err = " + str(spiceSimCount_lsq) + " " + str(rmsErr)
        printme = "least-sq iteration count, rms Err = " + str(iterationCount_lsq) + " " + str(rmsErr)
        print('\r',printme, end = "")



    spiceSimCount_lsq += 1

    return err

def update_netlist(kwargs,componentVal)  :
    netlist_fname = kwargs['netlist_fnameD']
    numlines_netlist = kwargs['numlines_netlistD']
    netlist = kwargs['netlistD']
    OptLine = kwargs['OptLineD']
    numOptd = kwargs['numOptdD']
    paramFlag = kwargs['paramFlagD']
    # print('\ncurrent component values')
    for k in range(numOptd):  # only write the opt lines to the in-memory netlist
        if paramFlag[k] == 0:
            netlist[OptLine[k]][3] = f'{componentVal[k]:.12e}'
            # print(f'{netlist[OptLine[k]][0]} {componentVal[k]:.12e}')
        else:
            netlist[OptLine[k]][2] = f'{componentVal[k]:.12e}'
            # print(f'{netlist[OptLine[k]][1]} {componentVal[k]:.12e}')
    with open(netlist_fname, 'w') as fid_wr_netlist:
        for k in range(numlines_netlist):
            thisLine = netlist[k]
            fid_wr_netlist.write(' '.join(thisLine) + '\n')
    return
def runSim(LTspice_outputfile, RunLTstring) :
    # run an LTspice sim. Assumes netlist is already written.
    # this code will stall until the .raw file has been written
    # The LTspice sim time can be highly variable in cases where it's
    # difficult to find a DC operating point
    if(os.path.isfile(LTspice_outputfile)) :
        os.remove(LTspice_outputfile) # delete in case of previous pass
    # Create an empty raw file
    with open(LTspice_outputfile, 'w') as fp:
        pass
    # get hash of .raw file so we know when the spice sim is done
    md5=hashlib.md5(open(LTspice_outputfile,'rb').read()).hexdigest()
    # Run the simulation. First check to make sure LTspice is not running from last call
    status = subprocess.call(RunLTstring, shell=True) # run it
    md5_post = md5 # start by assuming its not done (hash hasnt changed)
    while md5_post == md5 : # sleep until the hash of the raw file changes
        time.sleep(0.2)
        md5_post=hashlib.md5(open(LTspice_outputfile,'rb').read()).hexdigest()
    if status:
        print('ERROR, LTspice sim failed to run. Check setup')
        sys.exit()
    time.sleep(0.2)

# **********************************************************
# reads in the original schematic and replaces the instance values
# with the optimized insatnce values
def update_schematic(pass2schem, simControlDict, optParams):

    numOptd = pass2schem['numOptdD']
    OptLine = pass2schem['OptLineD']
    nomParams = pass2schem['nomParamsD']
    netlist = pass2schem['netlistD']
    filePath = pass2schem['filePathD']
    fileName = pass2schem['fileNameD']
    simctrlInstTol = simControlDict['simControlInstTolD']
    simctrlOptInstNames = simControlDict['simControlOPtInstNamesD']
    # Read in schematic to update
    schem_fname = os.path.join(filePath, fileName + '.asc')
    with open(schem_fname, 'r') as file:
        schem = file.readlines()

    changeNext = False
    roundStringNext = 'E96'
    new_schem = []

    for line in schem:
        line = line.strip().split()

        if changeNext: #  previous line was something like  'SYMATTR InstName R1' current line is like 'SYMATTR Value 600'
            newVal = round63(instValNext, roundStringNext)
            newVal = newVal[0].astype('float') # change from type ndarray to single float

            line[2] = f'{newVal:.3e}'
            print(f'Inst, opt val, quantized val = {instNm} {instValNext} {newVal:.3e}')
            changeNext = False

        if line[1] == 'InstName':
            instNm = line[2]
            changeNext = False
            for kk in range(numOptd):
                if netlist[OptLine[kk]][0] == instNm:
                    # Find the index to this instance in simctrlOptInstNames
                    # so that we know which tolerance to use
                    xx = simctrlOptInstNames.index(instNm)
                    # Next line has the value to change
                    changeNext = True
                    instValNext = optParams[kk] * nomParams[kk]  # de-normalize
                    roundStringNext = simctrlInstTol[xx]

        # test if there is a .param line, like 'TEXT -40 -88 Left 2 !.param C2VAL 1.3nf'
        testParam = '!.param'
        if testParam in line:
            idx = line.index(testParam) #  next position in line holds value of param
            paramName = line[idx+1]
            for kk in range(numOptd):
                if netlist[OptLine[kk]][1] == paramName:
                    xx = simctrlOptInstNames.index(paramName) #  find position in simcontrol list so we can get the tolerance
                    roundString = simctrlInstTol[xx] #  the E series tolerance
                    instVal = optParams[kk] * nomParams[kk]
                    newVal = round63(instVal, roundString)
                    newVal = newVal[0].astype('float')  # change from type ndarray to single float
                    line[idx + 2] = f'{newVal:.3e}'
                    print(f'Param, opt val, quantized val = {paramName} {instVal} {newVal:.3e}')


        new_schem.append(' '.join(line) + '\n')

    # Write new schem file
    schem_fname = os.path.join(filePath, fileName + '_opt.asc')
    with open(schem_fname, 'w') as file:
        file.writelines(new_schem)

# **********************************************************
# function to round component values to tolerance defined by "E-series"
# (c) 2014-2022 Stephen Cobeldick, converted from Matlab distribution
def round63(X, ser, rnd=None):
    # Constants for E-Series
    E_SERIES = {
        'E3': np.array([100, 220, 470]), # 40% tol
        'E6': np.array([100, 150, 220, 330, 470, 680]), # 20% tol
        'E12': np.array([100, 120, 150, 180, 220, 270, 330, 390, 470, 560, 680, 820]), #10%
        'E24': np.array([ # 5% tol
            100, 110, 120, 130, 150, 160, 180, 200, 220, 240, 270, 300,
            330, 360, 390, 430, 470, 510, 560, 620, 680, 750, 820, 910
        ]),
        'E48': np.array([ # 2% tol
            100, 105, 110, 115, 121, 127, 133, 140, 147, 154, 162, 169,
            178, 187, 196, 205, 215, 226, 237, 249, 261, 274, 287, 301,
            316, 332, 348, 365, 383, 402, 422, 442, 464, 487, 511, 536,
            562, 590, 619, 649, 681, 715, 750, 787, 825, 866, 909, 953
        ]),
        'E96': np.array([ # 1% tol
            100, 102, 105, 107, 110, 113, 115, 118, 121, 124, 127, 130,
            133, 137, 140, 143, 147, 150, 154, 158, 162, 165, 169, 174,
            178, 182, 187, 191, 196, 200, 205, 210, 215, 221, 226, 232,
            237, 243, 249, 255, 261, 267, 274, 280, 287, 294, 301, 309,
            316, 324, 332, 340, 348, 357, 365, 374, 383, 392, 402, 412,
            422, 432, 442, 453, 464, 475, 487, 499, 511, 523, 536, 549,
            562, 576, 590, 604, 619, 634, 649, 665, 681, 698, 715, 732,
            750, 768, 787, 806, 825, 845, 866, 887, 909, 931, 953, 976
        ]),
        'E192': np.array([ # 1/2 % tolerance
            100, 101, 102, 104, 105, 106, 107, 109, 110, 111, 113, 114,
            115, 117, 118, 120, 121, 123, 124, 126, 127, 129, 130, 132,
            133, 135, 137, 138, 140, 142, 143, 145, 147, 149, 150, 152,
            154, 156, 158, 160, 162, 164, 165, 167, 169, 172, 174, 176,
            178, 180, 182, 184, 187, 189, 191, 193, 196, 198, 200, 203,
            205, 208, 210, 213, 215, 218, 221, 223, 226, 229, 232, 234,
            237, 240, 243, 246, 249, 252, 255, 258, 261, 264, 267, 271,
            274, 277, 280, 284, 287, 291, 294, 298, 301, 305, 309, 312,
            316, 320, 324, 328, 332, 336, 340, 344, 348, 352, 357, 361,
            365, 370, 374, 379, 383, 388, 392, 397, 402, 407, 412, 417,
            422, 427, 432, 437, 442, 448, 453, 459, 464, 470, 475, 481,
            487, 493, 499, 505, 511, 517, 523, 530, 536, 542, 549, 556,
            562, 569, 576, 583, 590, 597, 604, 612, 619, 626, 634, 642,
            649, 657, 665, 673, 681, 690, 698, 706, 715, 723, 732, 741,
            750, 759, 768, 777, 787, 796, 806, 816, 825, 835, 845, 856,
            866, 876, 887, 898, 909, 920, 931, 942, 953, 965, 976, 988
        ])
    }

    def r63ss2c(arr):
        if isinstance(arr, str) and len(arr) == 1:
            return arr
        return arr

    def round_to_series(x, series):
        return series[np.argmin(np.abs(x - series))]

    if rnd is None:
        #rnd = 'harmonic'
        rnd = 'arithmetic'

    rnd = r63ss2c(rnd).lower()

    if ser not in E_SERIES:
        raise ValueError(f'Series "{ser}" is not supported.')

    ns = E_SERIES[ser]
    pwr = np.log10(X)
    idr = np.isfinite(pwr) & np.isreal(pwr)

    if not np.any(idr):
        return np.full_like(X, np.nan)

    # Determine the order of PNS magnitude required
    omn = np.floor(np.min(pwr[idr])) # -4 debug
    omx = np.ceil(np.max(pwr[idr])) # -3 debug

    # Extrapolate the PNS vector to cover all input values
    temp = 10.0 ** np.arange(omn - 3, omx-1)
    temp = temp.reshape((-1,1)) # make 2D row vect
    temp = temp.T # transpose, change shape from 4x1 to 1x4
    ns = ns.reshape((-1,1)) # make 2d row vect

    pns = ns * temp

    # now we need to flatten
    pns = pns.flatten(order = 'F')
    # Generate bin edge values
    if rnd == 'harmonic':
        edg = 2 * pns[:-1] * pns[1:] / (pns[:-1] + pns[1:])
    elif rnd == 'arithmetic':
        edg = (pns[:-1] + pns[1:]) / 2
    elif rnd == 'up':
        edg = pns[:-1]
    elif rnd == 'down':
        edg = pns[1:]
    else:
        raise ValueError(f'Rounding method "{rnd}" is not supported.')

    # Place values of X into PNS bins
    idx = np.digitize(X[idr], edg)
    idx[idx == 0] = 1  # Handle values below the smallest bin edge

    # Use the bin indices to select output values from the PNS
    Y = pns[idx - 0]

    return Y


# *********************************************************
# ************************** Main *************************
# *********************************************************

def main():
    global passcellDict
    updateType = 0
    simControlDict = simControl()  # Read simulation control input file, filled out by user

    fileName = simControlDict['fileNameD']
    spicePath = simControlDict['spicePathD']
    filePath = simControlDict['filePathD']
    simControlOPtInstNames = simControlDict['simControlOPtInstNamesD']
    simControlMinVals = simControlDict['simControlMinValsD']
    simControlMaxVals = simControlDict['simControlMaxValsD']
    simControlInstTol= simControlDict['simControlInstTolD']
    LTspice_output_node = simControlDict['LTSPice_output_nodeD']
    matchMode = simControlDict['matchModeD']
    maxIter_lsq = simControlDict['maxIter_lsqD']
    maxIter_ps = simControlDict['maxIter_psD']
    if matchMode == 4: # time domain sim
        numTimePoints = simControlDict['numTimePointsD']



    # Derived file paths and run scripts
    netlist_fname = f'{filePath}{fileName}.net'  # Netlist filename
    LTspice_outputfile = f'{filePath}{fileName}.raw'  # sim results filename
    RunLTstring = f'start "LTspice" "{spicePath}" -b "{filePath}{fileName}.net"'

    passCellDict['spicePathD'] = spicePath
    passCellDict['filePathD'] = filePath
    passCellDict['fileNameD'] = fileName
    passCellDict['filePathD'] = filePath
    passCellDict['netlist_fnameD'] = netlist_fname
    passCellDict['RunLTstringD'] = RunLTstring
    passCellDict['LTspice_outputfileD'] = LTspice_outputfile
    passCellDict['LTspice_output_nodeD'] = LTspice_output_node
    passCellDict['matchModeD'] = matchMode
    passCellDict['maxIter_lsqD'] = maxIter_lsq
    passCellDict['maxIter_psD'] = maxIter_ps
    if matchMode == 4:
        passCellDict['numTimePointsD'] = numTimePoints
    # Send command to write netlist
    string = f'start "LTspice" "{spicePath}" -netlist "{filePath}{fileName}.asc"'
    print(f'Issuing command to write LTspice netlist\n{string}')
    status = subprocess.call(string, shell=True)
    time.sleep(0.2) # in theory, subprocess.call is 'blocking', but it doesn't always work, so...


    # Read in the initial netlist. This will be held in memory and modified for every
    # pass through the least-squares. Inside the least-squares function
    # the netlist will be written to a file for each pass, so that LTspice can run
    with open(netlist_fname, 'r') as fid:
        netlist = fid.readlines()

    netlist = [line.strip().split() for line in netlist]  # Split lines into words
    numlines_netlist = len(netlist)
    passCellDict['netlistD'] = netlist
    passCellDict['numlines_netlistD'] = numlines_netlist

    # Find how many components are being optimized and make an index that points
    # to the line number in the netlist of those components
    # this makes the least-squares evaluation function faster because it doesn't
    # need to search through the entire netlist each time
    numOptd = len(simControlOPtInstNames)  # Number of instances being optimized
    OptLine = [0] * numOptd  # An array that points to the netlist lines with the instance names to be optimized


    kkk = 0
    OptLine = [0] * numOptd  # Initialize the OptLine array
    UB = [0.0] * numOptd  # Initialize the upper bound array
    LB = [0.0] * numOptd  # Initialize the lower bound array
    refType = [0] * numOptd  # Initialize the r-l-c part type array (0=R,1=L,2=C)

    for kk in range(numOptd):  # search all opt instance names to see if they are on the kth netlist line
        for k in range(numlines_netlist):  # Go through all netlist lines to look for this instance
            thisLine = netlist[k]
            #  if simControlOPtInstNames[kk] in thisLine[0]:
            #  if thisLine[0].count(simControlOPtInstNames[kk]) > 0:
            #  print(simControlOPtInstNames[kk])
            #  print(thisLine)
            for j in range(len(thisLine)): # scan the netlist line to see if it contains the optInstName
                if thisLine[j] == simControlOPtInstNames[kk]: # this could be an instance OR a parameter
                    OptLine[kkk] = k
                    UB[kkk] = float(simControlMaxVals[kk])  # Upper bound to pass to optimizer
                    LB[kkk] = float(simControlMinVals[kk])  # Lower bound to pass to optimizer
                    kkk += 1
                    break

    numMatchingInstFound = kkk

    if numOptd != numMatchingInstFound:
        print('ERROR;')
        print(f'number of instances to be optimized in control file = {numOptd}')
        print(f'number of matching instances found in netlist = {numMatchingInstFound}')
        print('check Instance name spelling in control file')
        sys.exit()

    passCellDict['numOptdD'] = numOptd
    passCellDict['OptLineD'] = OptLine
    passCellDict['updateTypeD'] = updateType
    nomParams = [0.0] * numOptd
    # This holds the nominal values, initialized to schematic values

    paramFlag = [0] * numOptd #  this will indicate a netlist line that contains a wiggleable parameter instead of a component value
    for k in range(numOptd):
        thisLine = netlist[OptLine[k]]  # Only lines that will be optimized here
        #  print('*** debug, netlist line = ',thisLine)
        if thisLine[0] == '.param':
            paramFlag[k] = 1
            newStr = thisLine[2] #  value is 3rd elemnt in line

        else:
            newStr = thisLine[3]  # Value is 4th element in line
        # Replace any 'micro' symbols from LTspice with 'u'
        newStr = newStr.replace(chr(181), 'u')  # Replace micro symbol with 'u'

        if not newStr.isnumeric():  # If it's not a number, handle symbols like k, M, pf, etc.
            newStr = newStr.replace('M', 'e6')
            newStr = newStr.replace('G', 'e9')
            newStr = newStr.lower()
            newStr = newStr.replace('k', 'e3')
            newStr = newStr.replace('pf', 'e-12')
            newStr = newStr.replace('ph', 'e-12')
            newStr = newStr.replace('p', 'e-12')
            newStr = newStr.replace('nf', 'e-9')
            newStr = newStr.replace('nh', 'e-9')
            newStr = newStr.replace('n', 'e-9')
            newStr = newStr.replace('uf', 'e-6')
            newStr = newStr.replace('uh', 'e-6')
            newStr = newStr.replace('u', 'e-6')
            newStr = newStr.replace('mf', 'e-3')
            newStr = newStr.replace('mh', 'e-3')
            newStr = newStr.replace('m', 'e-3')
        nomParams[k] = float(newStr)

    passCellDict['nomParamsD'] = nomParams
    passCellDict['paramFlagD'] = paramFlag


    print('\n*** setup file info, please check ***\n')
    print('inst name, init value, Min, Max, Tolerance ***\n')
    for k in range(numOptd):
        if paramFlag[k] == 0:
            print(f'{netlist[OptLine[k]][0]} {nomParams[k]:.12e} {LB[k]} {UB[k]} {simControlInstTol[k]}')
        else:
            print(f'{netlist[OptLine[k]][1]} {nomParams[k]:.12e} {LB[k]} {UB[k]} {simControlInstTol[k]}')
        # if nomParams[k] > UB[k] or nomParams[k] < LB[k]:
        #     print("error, nom instance value outside given bounds ",netlist[OptLine[k]][0])
        #     raise Exception("ERROR, component value outside given bounds")

    print('\nLTspice output node from setup file = ',LTspice_output_node,'\n')
    print('LTspice run command = ',RunLTstring,'\n')
    if matchMode == 1:
        print('Match mode = Amplitude Only\n')
    if matchMode == 2:
        print('Match mode = Phase Only\n')
    if matchMode == 3:
        print('Match mode = Amplitude + Phase\n')
    if matchMode == 4:
        print('Match mode = Transient sim waveform\n')

    x = input('Check accuracy above, enter C to continue or any other key to exit ')
    if x.lower() != 'c':
        sys.exit()

    # Run initial simulation to get frequencies
    print(f'Issuing command to run initial LTspice simulation\n{RunLTstring}')

    runSim(LTspice_outputfile,RunLTstring)
    
    # read the .raw sim results
    LTR = RawRead(LTspice_outputfile)
    outNode = LTR.get_trace(LTspice_output_node)
    if matchMode < 4: # freq response sim
        fresp = np.abs(outNode)
        if matchMode == 2 or matchMode == 3: # only compute phase if you are going to use it
            phase = np.unwrap(np.angle(outNode))
        freqx = LTR.get_trace('frequency')
        freqx = np.abs(freqx)
        numFreqs = len(freqx)
        [target, errWeights] = setTarget(freqx, matchMode)
    if matchMode == 4: #  time-domain sim
        timex = LTR.get_trace('time')
        timex = np.abs(timex)  ## sometimes the function returns a neg value, but otherwise correct ??
        timexLinspace = np.linspace(np.min(timex), np.max(timex), numTimePoints)
        outNodeLinspace = np.interp(timexLinspace,timex,outNode)
        [target, errWeights] = setTarget(timexLinspace) # target is a time-domain waveform



    passCellDict['targetD'] = target
    passCellDict['errWeightsD'] = errWeights
    if matchMode==3: # target is concatenation of ampl and phase, seperate out for plotting
        target_fresp = target[0:numFreqs]
        errWeights_fresp = errWeights[0:numFreqs]
        target_phase = target[numFreqs:]
        errWeights_phase = errWeights[numFreqs:]

    # plot the results of the initial sim on top of the target response, as well as the error weights

    if matchMode == 1:  # Ampl only match
        myPlot_2x_errweights('target/init sim', 'error weights','fresp',freqx,fresp,target,errWeights,'init sim','target',1,'target+init_sim.png')
    if matchMode == 2:  # Phase only match
        myPlot_2x_errweights('target/init sim', 'error weights','phase',freqx,fresp,target,errWeights,'init sim','target',1,'target+init_sim.png')
    if matchMode == 3:  # Both phase and ampl match
        myPlot_2x_errweights('target/init sim', 'error weights','fresp',freqx,fresp,target,errWeights,'init sim','target',1,'target+init_sim.png')
        myPlot_2x_errweights('target/init sim', 'error weights','phase',freqx,fresp,target,errWeights,'init sim','target',1,'target+init_sim.png')
    if matchMode == 4: # time domain sim
        myPlot_2x_errweights('target/init sim', 'error weights','transient',timexLinspace,outNodeLinspace,target,errWeights,'init sim','target',1,'target+init_sim.png')

    x = input('Check initial sim and target plots, enter C to continue or any other key to exit ')
    if x.lower() != 'c':
        sys.exit()

    if updateType == 0:
        UB = [ub / nom for ub, nom in zip(UB, nomParams)]  # Translate upper bounds into relative upper bounds
        LB = [lb / nom for lb, nom in zip(LB, nomParams)]  # Translate lower bounds into relative lower bounds
    if updateType == 1:
        for j in range(numOptd):
            UB[j] = np.log(UB[j]) - np.log(nomParams[j])
            LB[j] = np.log(LB[j]) - np.log(nomParams[j])
    # val = nom_val*exp(X), log(val)=X+log(nom_val), X = log(val)-log(nom_val), Xmax=log(val_max)-log(nom_val)

    passCellDict['LBD'] = LB
    passCellDict['UBD'] = UB

    optParams = np.ones(numOptd) # optimizer input var optParams is multiplied by nomParams before netlisting and simulation
    # run least-squares, step size is set higher than the default,
    # so that ltspice sim can see a difference in the response when the components are wiggled

    print('\n**************\nEntering Particle-swarm Global Optimization Loop, please be patient ...\n************')
    # Set-up hyperparameters
    options = {'c1': 0.5, 'c2': 0.3, 'w': 0.9}
    bounds = (LB, UB)
    n_particles = 30
    passCellDict['numParticlesD'] = n_particles
    # Call instance of GlobalBestPSO
    optimizer = ps.single.GlobalBestPSO(n_particles=n_particles, dimensions=numOptd,
                                        options=options, bounds = bounds)
    # Perform optimization
    bestCost,optParams = optimizer.optimize(pswarm, iters=maxIter_ps)

    print('**************\nEntering Least-sq Optimization Loop, please be patient ...\n************')

    if matchMode == 4: #  use bigger steps for time-domain sims
        diffStep = 1.0e-2
    else:
        diffStep = 1.0e-5

    if maxIter_lsq > 0:
        optParams = least_squares(optLTspice, optParams,method = 'trf',bounds=(LB, UB),diff_step=diffStep, ftol=1e-5,kwargs=passCellDict).x  # Optimize using least_squares function

        # optParams = least_squares(optLTspice, optParams,method = 'trf',bounds=(LB, UB),diff_step=1e-5, ftol=1e-5,kwargs=passCellDict).x  # Optimize using least_squares function

    #  passCellDict['XD'] = optParams

    print('************\nDONE! Generating outputs ...\n***********')


    for k in range(numOptd):
        print(f'{netlist[OptLine[k]][0]} {optParams[k] * nomParams[k]}')

    time.sleep(0.1)
    # Re-run simulation with current netlist.
    #  Just to make sure the simulation results are matched to the optimized component vals

    print('\nFINAL optimized component values')
    componentVal = np.zeros(numOptd)
    for k in range(numOptd):
        componentVal[k] = optParams[k] * nomParams[k]  # de-normalize
    update_netlist(passCellDict, componentVal)
    time.sleep(0.1)
    print(f'Issuing command to run post-opt LTspice simulation\n{RunLTstring}')
    runSim(LTspice_outputfile,RunLTstring)
    print(f'Done simulation, plotting\n')
    time.sleep(1)
    LTR = RawRead(LTspice_outputfile)
    outNode = LTR.get_trace(LTspice_output_node)

    if matchMode < 4:
        fresp_opt = np.abs(outNode)
        if matchMode == 2 or matchMode == 3:
            phase_opt = np.unwrap(np.angle(outNode))

    if matchMode == 4:  # time-domain sim
        timex = LTR.get_trace('time')
        timex = np.abs(timex)  ## sometimes the function returns a neg value, but otherwise correct ??
        timexLinspace = np.linspace(np.min(timex), np.max(timex), numTimePoints)
        outNodeLinspace = np.interp(timexLinspace, timex, outNode)

    # plot opt results before schematic generation/component quantization
    if matchMode == 1 or matchMode == 3:
        myPlot_2x('opt vs target sim','fresp',freqx,fresp_opt,target,'opt response','target',1,'opt_vs_target.png')

    if matchMode == 2 or matchMode==3:  # Phase
        myPlot_2x('opt vs target sim','phase',freqx,phase_opt,target,'opt response','target',1,'opt_vs_target.png')

    if matchMode == 4:  # time domain sim
        myPlot_2x('opt vs target sim','transient',timexLinspace,outNodeLinspace,target,'opt transient sim','target',1,'opt_vs_target.png')

    # generate a new schematic with '_opt' appended to name, with the optimized values
    # Note the optimized values are quantized based on the user "E-series" inputs.
    # This is currently outside the optimization loop. If you need better performance
    # I suggest you take the worst-tolerance components and remove them from the
    # list of instances to be optimized, and then re-run the optimizer based on the
    # new '_opt' schematic. 
    update_schematic(passCellDict, simControlDict,optParams)  # Write a new _opt schematic (Quantization applied on write-out)
    time.sleep(0.1)
    print(f'\nNew schematic with optimum component values generated\nFilename = {filePath}{fileName}_opt.asc')

    # Re-run simulation on the "_opt" schematic to check the quantization
    # Send command to write netlist
    string = f'"{spicePath}" -netlist "{filePath}{fileName}_opt.asc"'
    print(f'Issuing command to write new netlist from optimized schematic\n{string}')
    status = subprocess.call(string, shell=True)
    time.sleep(0.1)

    RunLTstring_opt = f'"{spicePath}" -b "{filePath}{fileName}_opt.net"'
    LTspice_outputfile_opt = f'{filePath}{fileName}_opt.raw'

    # Run sim on _Opt schematic

    print(f'\nIssuing command to run post-opt LTspice simulation w quant values\n{RunLTstring_opt}')
    
    runSim(LTspice_outputfile_opt,RunLTstring_opt)

    LTR = RawRead(LTspice_outputfile_opt)
    outNode = LTR.get_trace(LTspice_output_node)

    #  compute quantized ampl/phase/time
    if matchMode < 4:
        fresp_opt_quant = np.abs(outNode)
        if matchMode == 2 or matchMode == 3:
            phase_opt_quant = np.unwrap(np.angle(outNode))
    if matchMode == 4:  # time-domain sim
        timex = LTR.get_trace('time')
        timex = np.abs(timex)  ## sometimes the function returns a neg value, but otherwise correct ??
        timexLinspace = np.linspace(np.min(timex), np.max(timex), numTimePoints)
        outNodeLinspace_quant = np.interp(timexLinspace, timex, outNode)

    #  Plot the target, optimized, and quantized (from new schem) optimized responses

    if matchMode == 1 or matchMode == 3:
        myPlot_2x('opt_quant vs target sim', 'fresp', freqx, fresp_opt_quant, target, 'quant opt response','target', 1, 'optquant_vs_target.png')
    if matchMode == 2:
        myPlot_2x('opt_quant vs target sim', 'phase', freqx, phase_opt_quant, target, 'quant opt response', 'target', 1, 'optquant_vs_target.png')
    if matchMode == 4:
        myPlot_2x('opt_quant vs target sim','transient',timexLinspace,outNodeLinspace_quant,target,'opt quant transient sin','target',1,'optquant_vs_target.png')

    print('\n******* DONE! ******\n')
    # print('Best error from PS only was ',bestCost)
    x = input('any key to exit .... ')
    sys.exit()

if __name__ == "__main__":
    main()